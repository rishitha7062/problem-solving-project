2.1 Problem Statement:-
A futuristic company is building an autonomous car. The scientists at the company are training the car to perform Reverse parking. To park, the car needs to be able to move in backward as well as forward direction. The car is programmed to move backwards B meters and forwards again, say F meters, in a straight line. The car does this repeatedly until it is able to park or collides with other objects. The car covers 1 meter in T units of time. There is a wall after distance D from car's initial position in the backward direction. The car is currently not without defects and hence often hits the wall. The scientists are devising a strategy to prevent this from happening. Your task is to help the scientists by providing them with exact information on amount of time available before the car hits the wall.

Input:-
First line contains total number of test cases, denoted by N Next N lines, contain a tuple containing 4 values delimited by space F B T D, where

F denotes forward displacement in meters
B denotes backward displacement in meters
T denotes time taken to cover 1 meter
D denotes distance from Car's starting position and the wall in backward direction
Output:-
For each test case print time taken by the Car to hit the wall

Constraints:-
First move will always be in backward direction 1 <= N <= 100 backward displacement > forward displacement i.e. (B > F) forward displacement (F) > 0 backward displacement (B) > 0 time (T) > 0 distance (D) > 0 All input values must be positive integers only

Sample Input and Output:-
2

6 9 3 18

3 7 5 20

162

220
coding:
#include<stdio.h>
int main()
{
    int n,c[10],i1,i;
    int f,b,t,d;
    scanf("%d",&n);
    if(n>0)
    {
        while(n--)
        {
            scanf("%d%d%d%d",&f,&b,&t,&d);
            int current_pos=0;
            int count=0;
            int totaltime=0;
            if(f>=b || d == 0 || t == 0)
                printf("Cannot park\n");
            else
            {
                while(1)
                {
                    if(current_pos+b<d)//distanced covered+b<d
                        current_pos+=b;//backward move
                    else   
                    {   
                         totaltime=(d-current_pos)*t;//remaining distance*t 
                        break;  
                    }
                    current_pos-=f;//forwared move
                    count++;//count no. of bacward and forward
                }
                 totaltime+=(count*t)*(f+b); //total time
        
            }
             c[i1++]=totaltime;
        }
        
    }
    else
    {
        printf("Invalid test case");
    }
    for(i=0;i<i1;i++)
        printf("%d\n", c[i]);
    return 0;
}
